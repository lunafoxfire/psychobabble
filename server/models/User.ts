import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, OneToMany, OneToOne, JoinColumn } from "typeorm";
import { Role } from "./Role";
import { ProgramRequest } from "./ProgramRequest";
import { Program } from "./Program";
import { Response } from "./Response";
import { ValidationToken } from "./ValidationToken";
import { PassResetToken } from "./PassResetToken";
import { randomBytes, pbkdf2Sync } from 'crypto';
import * as jwt from 'jsonwebtoken';

/** Represents a site user. */
@Entity('users')
export class User {
  /** Autogenerated id as a UUID string. */
  @PrimaryGeneratedColumn("uuid")
  id: string;

  /**  User's username. */
  @Column()
  username: string;

  /** User's username normalized for database storage and lookup. */
  @Column()
  normalized_username: string;

  /** User's email. Nullable. */
  @Column({nullable: true})
  email: string;

  /** User's email normalized for database storage and lookup. Nullable. */
  @Column({nullable: true})
  normalized_email: string;

  /** Salt for hashing the User's password. */
  @Column()
  salt: string;

  /** Hash of the User's password. */
  @Column()
  hash: string;

  /** Date the User was created as a UNIX timestamp. */
  @Column({type: 'bigint'})
  date_created: number;

  /** User's Role, defining their permissions. */
  @ManyToOne(type => Role, role => role.users, {eager: true})
  role: Role;

  /** Whether this user is awaiting email validation. */
  @Column()
  validated: boolean;

  /** All ProgramRequests generated by this User as a client. */
  @OneToMany(type => ProgramRequest, programRequests => programRequests.client)
  programRequests: ProgramRequest[];

  /** All Programs created by this User as an admin. */
  @OneToMany(type => Program, program => program.author)
  createdPrograms: Program[];

  /** All Programs this User is subscribed to as a client. */
  @OneToMany(type => Program, program => program.client)
  clientPrograms: Program[];

  /** All responses to Program videos this user has made as a subject. */
  @OneToMany(type => Response, responses => responses.subject, {eager: true})
  responses: Response[];

  /** Generated token to verify this User's email. */
  @OneToOne(type => ValidationToken, {eager: true})
  @JoinColumn()
  validationToken: ValidationToken;

  /** Hash for password reset url generation */
  @OneToOne(type => PassResetToken, {eager: true})
  @JoinColumn()
  passResetToken: PassResetToken;

  /** Checks whether the given password is the user's password. */
  public validateLogin(password: string): boolean {
    return User.hashPassword(password, this.salt) == this.hash;
  }

  /** Returns a new JWT correctly signed and containing the user's info. */
  public generateJwt() {
    let expiration = new Date();
    expiration.setDate(expiration.getDate() + 7); // Expire in one week
    return jwt.sign({
      id: this.id,
      username: this.username,
      email: this.email,
      role: this.role.name,
      validated: this.validated,
      exp: expiration.getTime() / 1000
    }, process.env.JWT_SECRET);
  }

  public static genSalt(): string {
    return randomBytes(16).toString('hex');
  }

  public static hashPassword(password: string, salt: string): string {
    return pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');
  }

  public static normalizeField(field: string): string {
    return (field) ? field.toUpperCase() : null;
  }

  /** Checks if a username is a valid username. */
  public static checkUsername(username: string): boolean {
    const properLength = username.length >= 4 && username.length <= 20;
    const startsWithLetter = !!username.match(/^[a-z]/gi);
    const onlyValidChars = !!username.match(/^[a-z0-9\-_]*$/gi);
    return (properLength && startsWithLetter && onlyValidChars);
  }

  /** Checks if a password is a valid password. */
  public static checkPassword(password: string): boolean {
    const properLength = password.length >= 6 && password.length <= 32;
    const hasLetter = !!password.match(/[a-z]/gi);
    const hasNumber = !!password.match(/[0-9]/gi);
    return (properLength && hasLetter && hasNumber);
  }

  /** Checks if an email meets minimum requirements for a valid address. */
  public static checkEmail(email: string): boolean {
    const validEmail = !!email.match(/^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9-]+)*$/gi);
    return (validEmail);
  }
}
