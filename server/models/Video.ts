import {
  Entity, Column, PrimaryGeneratedColumn, OneToMany, ManyToMany, JoinTable,
  Repository, getRepository
} from "typeorm";
import { Program } from './Program';
import { Tag, TagType, TagService } from "./Tag";
import { Response } from "./Response";

/** A video object. */
@Entity('videos')
export class Video {
  /** Autogenerated id as a UUID string. */
  @PrimaryGeneratedColumn("uuid")
  id: string;

  /** The URL where this video is stored. Nullable. */
  @Column({nullable: true})
  url: string;

  /** A description of this video. Nullable. */
  @Column({nullable: true})
  description: string;

  /** All tags associated with this video. */
  @ManyToMany(type => Tag, tags => tags.videos)
  @JoinTable()
  tags: Tag[];

  /** All Programs containing this video. */
  @ManyToMany(type => Program, program => program.videos)
  programs: Program[];

  /** All subject Responses to this video. */
  @OneToMany(type => Response, responses => responses.video)
  responses: Response[];
}

export class VideoService {
  public videoRepo: Repository<Video>;
  private tagService: TagService;

  constructor(videoRepo: Repository<Video> = null, tagService: TagService = null) {
    this.videoRepo = videoRepo || getRepository(Video);
    this.tagService = tagService || new TagService();
  }

  public async createEmptyVideo(): Promise<string> {
    let video = new Video();
    await this.videoRepo.save(video);
    return video.id;
  }

  /** Saves a new Video to the database. */
  public async uploadAsync(videoOptions: VideoUploadOptions): Promise<Video> {
    let tags: Tag[] = [];
    if (videoOptions.tags) {
      await Promise.all(videoOptions.tags.map(async (tagType) => {
        tags.push(await this.tagService.findByNameAsync(tagType));
        return;
      }));
    }
    let newVideo = new Video();
      newVideo.id = videoOptions.id
      newVideo.url = videoOptions.url;
      newVideo.description = videoOptions.description;
      newVideo.tags = tags;
    return this.videoRepo.save(newVideo);
  }

  public async deleteVideoId(videoId) {
    let videoToDelete = await this.videoRepo.findOneById(videoId);
    await this.videoRepo.remove(videoToDelete);
    let check = await this.videoRepo.findOneById(videoId);
    if(check) {
      console.log(videoId);
      return false;
    } else {
      console.log(videoId);
      return true;
    }
  }
}

/** All options required to create a new Video. */
export interface VideoUploadOptions {
  /** The id where this video will be stored */
  id: string;
  /** The URL where this video is stored. */
  url: string;
  /** A description of this video. */
  description: string;
  /** All tags associated with this video. Optional. */
  tags?: TagType[];
}
