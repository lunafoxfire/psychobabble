import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, OneToMany, OneToOne, JoinColumn, getRepository } from "typeorm";
import { Role, RoleType } from "./Role";
import { ProgramRequest } from "./ProgramRequest";
import { Program } from "./Program";
import { Response } from "./Response";
import { ValidationToken } from "./ValidationToken";
import { PassResetToken } from "./PassResetToken";
import * as sgMail from '@sendgrid/mail';
sgMail.setApiKey(process.env.SENDGRID_API_KEY);
import { randomBytes, pbkdf2Sync } from 'crypto';
import * as jwt from 'jsonwebtoken';

/** Represents a site user. */
@Entity('users')
export class User {

  /** Autogenerated id as a UUID string. */
  @PrimaryGeneratedColumn("uuid")
  id: string;

  /**  User's username. */
  @Column()
  username: string;

  /** User's username normalized for database storage and lookup. */
  @Column()
  normalized_username: string;

  /** User's email. Nullable. */
  @Column({nullable: true})
  email: string;

  /** User's email normalized for database storage and lookup. Nullable. */
  @Column({nullable: true})
  normalized_email: string;

  /** Salt for hashing the User's password. */
  @Column()
  salt: string;

  /** Hash of the User's password. */
  @Column()
  hash: string;

  /** Date the User was created as a UNIX timestamp. */
  @Column({type: 'bigint'})
  date_created: number;

  /** User's Role, defining their permissions. */
  @ManyToOne(type => Role, role => role.users, {eager: true})
  role: Role;

  /** Whether this user is awaiting email validation. */
  @Column()
  validated: boolean;

  /** All ProgramRequests generated by this User as a client. */
  @OneToMany(type => ProgramRequest, programRequests => programRequests.client)
  programRequests: ProgramRequest[];

  /** All Programs created by this User as an admin. */
  @OneToMany(type => Program, program => program.author)
  createdPrograms: Program[];

  /** All Programs this User is subscribed to as a client. */
  @OneToMany(type => Program, program => program.client)
  clientPrograms: Program[];

  /** All responses to Program videos this user has made as a subject. */
  @OneToMany(type => Response, responses => responses.subject)
  responses: Response[];

  /** Generated token to verify this User's email. */
  @OneToOne(type => ValidationToken, {eager: true})
  @JoinColumn()
  validationToken: ValidationToken;

  /** Hash for password reset url generation */
  @OneToOne(type => PassResetToken, {eager: true})
  @JoinColumn()
  passResetToken: PassResetToken;

  /** Registers a new User to the database. */
  // TODO: Return some results object with more info on failures (taken username, etc.)
  public static async registerAsync(regOptions: UserRegistrationOptions): Promise<User> {
    let userRepo = getRepository(User);
    let usernameTaken = await User.findByEmailAsync(regOptions.username);
    let emailTaken = await User.findByEmailAsync(regOptions.email);
    if (!usernameTaken && !emailTaken) {
      let user = new User();
        user.username = regOptions.username;
        user.normalized_username = User.normalizeField(user.username);
        user.email = regOptions.email;
        user.normalized_email = User.normalizeField(user.email);
        user.salt = User.genSalt();
        user.hash = User.hashPassword(regOptions.password, user.salt);
        user.date_created = new Date().getTime();
        user.role = await Role.findByNameAsync(regOptions.roleType);
        user.validated = regOptions.preValidated || false;
      if (!user.validated) {
        user.validationToken = await ValidationToken.generateValidTokenAsync();
        user.sendValidationEmail();
      }
      await userRepo.save(user);
      return user;
    }
    else {
      return null;
    }
  }

  /** Registers a new admin to the database. */
  public static async registerAdminAsync(username: string, email: string, password: string): Promise<User> {
    return User.registerAsync({
      username: username,
      email: email,
      password: password,
      roleType: RoleType.Admin
    });
  }

  /** Registers a new client to the database. */
  public static async registerClientAsync(username: string, email: string, password: string): Promise<User> {
    return User.registerAsync({
      username: username,
      email: email,
      password: password,
      roleType: RoleType.Client
    });
  }

  /** Registers a new subject to the database. */
  public static async registerSubjectAsync(username: string, email: string, password: string): Promise<User> {
    return User.registerAsync({
      username: username,
      email: email,
      password: password,
      roleType: RoleType.Subject
    });
  }

  /** Generates the default admin account if no admin account currently exists. */
  public static async generateDefaultAdminIfNoAdminAsync(): Promise<User> {
    let adminRole = await Role.findByNameAsync(RoleType.Admin);
    let adminExists = await
    //TODO:Report this bug
    getRepository(User).findOne({role: adminRole.id}); // Ignore this type error. TypeORM apparently has some "quirks".
    if (adminExists) {
      return null;
    }
    else {
      return User.generateDefaultAdminAsync();
    }
  }

  /** Registers the default admin account to the database. */
  public static async generateDefaultAdminAsync(): Promise<User> {
    return User.registerAsync({
      username: process.env.DEFAULT_ADMIN_USERNAME,
      email: null,
      password: process.env.DEFAULT_ADMIN_PASSWORD,
      roleType: RoleType.Admin,
      preValidated: true
    });
  }

  /** Sends the user an email containing their validation token code. */
  public sendValidationEmail() {
    console.log(`Sending validation email to ${this.email}`);
    let msg = {
      to: this.email,
      from: process.env.NOREPLY_EMAIL,
      subject: 'Account Activation',
      html: `<h3>Please enter this code: ${this.validationToken.code}<h3>`,
    };
    sgMail.send(msg).catch((err) => {
      console.error(`SendGrid Error: ${err.code} - ${err.message}`);
    });
  }

  public static async resendValidationEmail(email) {
    let user = await this.findByEmailAsync(email);
    user.validationToken = await ValidationToken.generateValidTokenAsync();
    user.sendValidationEmail();
  }

  /** Sends the user an email to reset their password if they exist in database */
  public static async sendPassResetEmail(email, host) {
    let user = await this.findByEmailAsync(email);
    if(!user) {
      return false;
    } else {
      let url = await this.generateResetUrl(user, host);
      let msg = {
        to: email,
        from: process.env.NOREPLY_EMAIL,
        subject: 'Password Reset',
        html: `
        <h3>Password Reset</h3>
        <p>If you didn't request a password reset, ignore this email</p>
        <br>
        <strong><a href=${url}>Reset your password here</a><strong>
        `
      };
      sgMail.send(msg).catch((err) => {
        console.log(`SendGrid Error: ${err.code} - ${err.message}`);
      });
      return true;
    }
  }

  public static async resendPasswordResetEmail(userId, host) {
    let user = await getRepository(User).findOneById(userId);
    return await this.sendPassResetEmail(user.email, host);
  }

  public static async changePassword(newPass, userId) {
    let userRepo = getRepository(User);
    let user = await userRepo.findOneById(userId);
    if(user.passResetToken.expiration <= new Date().getTime()) {
      return 0;
    } else {
      let newHash = this.hashPassword(newPass, user.salt);
      if(newHash === user.hash) {
        return 1;
      } else {
        user.hash = newHash;
        userRepo.save(user);
        return 2;
      }
    }
  }

  /** Generates the url to be sent for password reset */
  public static async generateResetUrl(user: User, host) {
    let userRepo = getRepository(User);
    user.passResetToken = await PassResetToken.generatePassTokenAsync();
    await userRepo.save(user);
    let url = `http://${host}/reset/${user.id}/${user.passResetToken.code}`;
    console.log(url);
    return url;
  }

  /** Checks whether the given password is the user's password. */
  public validateLogin(password: string): boolean {
    return User.hashPassword(password, this.salt) == this.hash;
  }

  /** Returns a new JWT correctly signed and containing the user's info. */
  public generateJwt() {
    let expiration = new Date();
    expiration.setDate(expiration.getDate() + 7); // Expire in one week
    return jwt.sign({
      id: this.id,
      username: this.username,
      email: this.email,
      role: this.role.name,
      validated: this.validated,
      exp: expiration.getTime() / 1000
    }, process.env.JWT_SECRET);
  }

  /** Finds a user by username accounting for normalization. */
  public static async findByUsernameAsync(username: string): Promise<User> {
    return getRepository(User).findOne({normalized_username: User.normalizeField(username)});
  }

  /** Finds a user by email accounting for normalization. */
  public static async findByEmailAsync(email: string): Promise<User> {
    return getRepository(User).findOne({normalized_email: User.normalizeField(email)});
  }

  /** Finds a user by username or email for login puposes. */
  public static async findByLoginNameAsync(loginName: string): Promise<User> {
    let userByName = await User.findByUsernameAsync(loginName);
    let userByEmail = await User.findByEmailAsync(loginName);
    return (userByName || userByEmail);
  }

  private static genSalt(): string {
    return randomBytes(16).toString('hex');
  }

  private static hashPassword(password: string, salt: string): string {
    return pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');
  }

  private static normalizeField(field: string): string {
    return (field) ? field.toUpperCase() : null;
  }
}

/** All options required to register a new User. */
export interface UserRegistrationOptions {
  /** The User's username. */
  username: string;
  /** The User's email. */
  email: string;
  /** The User's password. */
  password: string;
  /** The User's role. */
  roleType: RoleType;
  /** Whether the user can skip email validation. Optional. */
  preValidated?: boolean;
}
